{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.esm.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\n\nexport function withFocusWithin(Component) {\n    const WrappedComponent = ({ onFocus, onBlur, ...props }) => (\n        <FocusWithin onFocus={onFocus} onBlur={onBlur}>\n            {({ getFocusProps, isFocused }) =>\n                typeof Component === 'string' ? (\n                    <Component {...getFocusProps(props)} />\n                ) : (\n                    <Component {...getFocusProps(props)} isFocused={isFocused} />\n                )\n            }\n        </FocusWithin>\n    )\n    WrappedComponent.displayName = `WithFocusWithin(${Component.displayName || Component.name || 'Component'})`\n    return WrappedComponent\n}\n\nexport class FocusWithin extends React.Component {\n    static propTypes = {\n        onBlur: PropTypes.func,\n        onFocus: PropTypes.func,\n    }\n\n    static defaultProps = {\n        onBlur: () => {},\n        onFocus: () => {},\n    }\n\n    static wrapComponent = withFocusWithin\n\n    state = {\n        isBlurring: false,\n        isFocused: false,\n    }\n\n    // delay by one turn of the event loop, used to consolidate timing between\n    // FocusWithin events and native events\n    delay = (cb, ...args) =>\n        setTimeout(() => {\n            if (this.isUnmounted) {\n                return\n            }\n            cb(...args)\n        })\n\n    setFocusState = (isFocused, isFocusWithinEvent) => {\n        const setStateCb = () => {\n            if (this.isUnmounted) return\n            this.setState(\n                state =>\n                    state.isFocused === isFocused\n                        ? state\n                        : !isFocused\n                            ? {\n                                  isFocused,\n                                  isBlurring: true,\n                              }\n                            : {\n                                  isFocused,\n                              }\n            )\n        }\n        // delay processing native events for one turn of the event loop\n        // to have it be on the same timing as FocusWithin events\n        if (isFocusWithinEvent) {\n            setStateCb()\n        } else {\n            this.delay(setStateCb)\n        }\n    }\n\n    // track mouse activity within the FocusWithin container, which allows clicking inside it\n    // whenever a mousedown occurs we save the current container element, and if on mouseup\n    // we are outside the container, we emit the blur event appropriately\n    // mouseups can still occur outside the container with actual DOM focus remaining within\n    // so we do not emit blurs for those\n    onDocumentMouseUp = event => {\n        const container = this.mouseDownWithinTarget\n        const mouseUpWithinTarget = container && container.contains(event.target)\n        const activeElementWithinTarget = container && container.contains(document.activeElement)\n        if (!activeElementWithinTarget && !mouseUpWithinTarget) {\n            this.setFocusState(false, this.lastBlurEvent ? this.lastBlurEvent.__isFocusWithinEvent : true)\n        }\n        this.mouseDownWithinTarget = null\n        this.lastBlurEvent = null\n    }\n\n    getFocusProps = ({ onFocus, onBlur, onMouseDown, ...props } = {}) => {\n        return {\n            ...props,\n            onFocus: event => {\n                const propagationStopped = onFocus && onFocus(event) === false\n                if (propagationStopped || (event && event.focusWithinDefaultPrevented)) {\n                    return\n                }\n                this.setFocusState(true, event && event.__isFocusWithinEvent)\n            },\n            onBlur: event => {\n                const propagationStopped = onBlur && onBlur(event) === false\n                if (propagationStopped || (event && event.focusWithinDefaultPrevented)) {\n                    return\n                }\n                // if blur event happens right after a mousedown of an element inside the FocusWithin container\n                // we don't emit the blur event immediately and check if we should emit it later after the mouseup occurs\n                if (this.mouseDownWithinTarget) {\n                    event.persist && event.persist()\n                    this.lastBlurEvent = event\n                    return\n                }\n                this.setFocusState(false, event && event.__isFocusWithinEvent)\n            },\n            onMouseDown: event => {\n                const propagationStopped = onMouseDown && onMouseDown(event) === false\n                if (propagationStopped || (event && event.focusWithinDefaultPrevented)) {\n                    return\n                }\n                this.mouseDownWithinTarget = event.currentTarget\n            },\n        }\n    }\n\n    componentDidMount() {\n        document.addEventListener('mouseup', this.onDocumentMouseUp)\n    }\n\n    componentDidUpdate(_, prevState) {\n        if (prevState.isFocused && !this.state.isFocused) {\n            this.delay(() => {\n                if (this.isUnmounted) {\n                    return\n                }\n                this.setState({\n                    isBlurring: false,\n                })\n                // check if the focus manager is actually blurred for times\n                // when document click causes a consective blur -> focus\n                if (!this.state.isFocused) {\n                    this.props.onBlur({ __isFocusWithinEvent: true })\n                }\n            })\n        }\n        // check if the focus manager was focused from the outside\n        // and not from another child element\n        // delay onfocus emission to be on the same timing as blur events\n        if (!this.state.isBlurring && !prevState.isFocused && this.state.isFocused) {\n            this.delay(this.props.onFocus, { __isFocusWithinEvent: true })\n        }\n    }\n\n    componentWillUnmount() {\n        this.isUnmounted = true\n        document.removeEventListener('mouseup', this.onDocumentMouseUp)\n    }\n\n    render() {\n        return this.props.children\n            ? this.props.children({\n                  focusProps: this.getFocusProps(),\n                  getFocusProps: this.getFocusProps,\n                  // stabilize isFocused so that it only changes corresponding to its event emissions\n                  isFocused: this.state.isFocused || this.state.isBlurring,\n              })\n            : null\n    }\n}\n\nexport default FocusWithin\n"]}